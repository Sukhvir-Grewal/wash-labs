{
    "sourceFile": "lib/auth.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1761927994673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1761927994673,
            "name": "Commit-0",
            "content": "import { serialize, parse } from 'cookie';\r\nimport crypto from 'crypto';\r\n\r\n// Session configuration\r\nconst SESSION_COOKIE_NAME = 'admin_session';\r\nconst SESSION_MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds\r\n\r\n/**\r\n * Hash password using PBKDF2 (built-in Node.js crypto, no external deps)\r\n * @param {string} password - Plain text password\r\n * @returns {string} Hashed password in format: salt.hash\r\n */\r\nexport function hashPassword(password) {\r\n  const salt = crypto.randomBytes(16).toString('hex');\r\n  const hash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');\r\n  return `${salt}.${hash}`;\r\n}\r\n\r\n/**\r\n * Verify password against hash\r\n * @param {string} password - Plain text password\r\n * @param {string} storedHash - Hash in format: salt.hash\r\n * @returns {boolean} True if password matches\r\n */\r\nexport function verifyPassword(password, storedHash) {\r\n  const [salt, hash] = storedHash.split('.');\r\n  const verifyHash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');\r\n  return hash === verifyHash;\r\n}\r\n\r\n/**\r\n * Create session token (random 32 bytes)\r\n * @returns {string} Session token\r\n */\r\nexport function createSessionToken() {\r\n  return crypto.randomBytes(32).toString('hex');\r\n}\r\n\r\n/**\r\n * Verify admin password against environment variable\r\n * @param {string} password - Plain text password to verify\r\n * @returns {boolean} True if password matches\r\n */\r\nexport function verifyAdminPassword(password) {\r\n  const adminPassword = process.env.ADMIN_PASSWORD;\r\n  \r\n  console.log('[verifyAdminPassword] Checking password...');\r\n  console.log('[verifyAdminPassword] Env password exists:', !!adminPassword);\r\n  console.log('[verifyAdminPassword] Env password length:', adminPassword?.length || 0);\r\n  console.log('[verifyAdminPassword] Input password length:', password?.length || 0);\r\n  \r\n  if (!adminPassword) {\r\n    console.error('[auth] ADMIN_PASSWORD environment variable not set');\r\n    return false;\r\n  }\r\n  \r\n  // Direct comparison (you can switch to hashed comparison later if needed)\r\n  const isMatch = password === adminPassword;\r\n  console.log('[verifyAdminPassword] Password match:', isMatch);\r\n  return isMatch;\r\n}\r\n\r\n/**\r\n * Create httpOnly session cookie\r\n * @param {string} token - Session token\r\n * @returns {string} Serialized cookie header\r\n */\r\nexport function createSessionCookie(token) {\r\n  return serialize(SESSION_COOKIE_NAME, token, {\r\n    httpOnly: true,\r\n    secure: process.env.NODE_ENV === 'production',\r\n    sameSite: 'strict',\r\n    maxAge: SESSION_MAX_AGE,\r\n    path: '/',\r\n  });\r\n}\r\n\r\n/**\r\n * Create logout cookie (expires immediately)\r\n * @returns {string} Serialized cookie header\r\n */\r\nexport function createLogoutCookie() {\r\n  return serialize(SESSION_COOKIE_NAME, '', {\r\n    httpOnly: true,\r\n    secure: process.env.NODE_ENV === 'production',\r\n    sameSite: 'strict',\r\n    maxAge: 0,\r\n    path: '/',\r\n  });\r\n}\r\n\r\n/**\r\n * Get session token from request cookies\r\n * @param {object} req - Next.js request object\r\n * @returns {string|null} Session token or null\r\n */\r\nexport function getSessionToken(req) {\r\n  const cookies = parse(req.headers.cookie || '');\r\n  return cookies[SESSION_COOKIE_NAME] || null;\r\n}\r\n\r\n/**\r\n * Simple session store that persists across Next.js processes\r\n * Using a global variable that survives hot reloads in development\r\n * In production, use Redis or a database\r\n */\r\nconst getSessionStore = () => {\r\n  // Use global to persist across hot reloads in development\r\n  if (!global._sessionStore) {\r\n    global._sessionStore = new Map();\r\n  }\r\n  return global._sessionStore;\r\n};\r\n\r\n/**\r\n * Store session token\r\n * @param {string} token - Session token\r\n * @param {object} data - Session data\r\n */\r\nexport function storeSession(token, data = {}) {\r\n  const sessions = getSessionStore();\r\n  sessions.set(token, {\r\n    ...data,\r\n    createdAt: Date.now(),\r\n    expiresAt: Date.now() + (SESSION_MAX_AGE * 1000),\r\n  });\r\n  console.log('[storeSession] Session stored. Total sessions:', sessions.size);\r\n}\r\n\r\n/**\r\n * Verify session token\r\n * @param {string} token - Session token\r\n * @returns {boolean} True if session is valid\r\n */\r\nexport function verifySession(token) {\r\n  console.log('[verifySession] Verifying token:', token ? `${token.substring(0, 10)}...` : 'No token');\r\n  \r\n  if (!token) {\r\n    console.log('[verifySession] No token provided');\r\n    return false;\r\n  }\r\n  \r\n  const sessions = getSessionStore();\r\n  const session = sessions.get(token);\r\n  console.log('[verifySession] Session found:', !!session);\r\n  console.log('[verifySession] Total sessions stored:', sessions.size);\r\n  \r\n  if (!session) {\r\n    console.log('[verifySession] Session not found in store');\r\n    return false;\r\n  }\r\n  \r\n  // Check if session expired\r\n  const now = Date.now();\r\n  const expired = now > session.expiresAt;\r\n  console.log('[verifySession] Session expired:', expired);\r\n  console.log('[verifySession] Now:', now, 'Expires:', session.expiresAt);\r\n  \r\n  if (expired) {\r\n    sessions.delete(token);\r\n    console.log('[verifySession] Session deleted due to expiration');\r\n    return false;\r\n  }\r\n  \r\n  console.log('[verifySession] Session is valid');\r\n  return true;\r\n}\r\n\r\n/**\r\n * Delete session token\r\n * @param {string} token - Session token\r\n */\r\nexport function deleteSession(token) {\r\n  const sessions = getSessionStore();\r\n  sessions.delete(token);\r\n  console.log('[deleteSession] Session deleted. Total sessions:', sessions.size);\r\n}\r\n\r\n/**\r\n * Middleware helper: verify admin authentication\r\n * @param {object} req - Next.js request object\r\n * @returns {boolean} True if authenticated\r\n */\r\nexport function isAuthenticated(req) {\r\n  console.log('[isAuthenticated] Checking authentication...');\r\n  console.log('[isAuthenticated] Request headers cookie:', req.headers.cookie);\r\n  \r\n  const token = getSessionToken(req);\r\n  console.log('[isAuthenticated] Token found:', token ? `${token.substring(0, 10)}...` : 'No token');\r\n  \r\n  const isValid = verifySession(token);\r\n  console.log('[isAuthenticated] Session valid:', isValid);\r\n  \r\n  return isValid;\r\n}\r\n\r\n/**\r\n * API middleware: require authentication\r\n * Returns 401 if not authenticated\r\n * @param {function} handler - API route handler\r\n * @returns {function} Wrapped handler\r\n */\r\nexport function requireAuth(handler) {\r\n  return async (req, res) => {\r\n    if (!isAuthenticated(req)) {\r\n      return res.status(401).json({ error: 'Unauthorized. Please login.' });\r\n    }\r\n    return handler(req, res);\r\n  };\r\n}\r\n"
        }
    ]
}